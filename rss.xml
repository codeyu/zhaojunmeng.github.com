<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"><channel><title>优格猫</title><link>http://yogurtcat.com</link><description>下顿吃啥好呢？让我们一起来觅食吧！</description><lastBuildDate>Mon, 01 Apr 2013 12:41:32 GMT</lastBuildDate><generator>nikola</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>CEF：给客户端内嵌一个Chrome吧</title><link>http://yogurtcat.com/posts/cef/hello-cef.html</link><description>&lt;html&gt;&lt;body&gt;&lt;h3&gt;CEF是什么&lt;/h3&gt;
&lt;p&gt;CEF是&lt;a href="http://code.google.com/p/chromiumembedded/" target="_blank"&gt;Chromium Embedded Framework&lt;/a&gt;的缩写，是个基于Google Chromium项目的开源Web browser控件，支持Windows, Linux, Max平台。除了提供C/C++接口外，也有其他语言的移植版。&lt;/p&gt;
&lt;p&gt;因为基于Chromium，所以CEF支持Webkit &amp;amp; Chrome中实现的HTML5的特性，并且在性能上面，也比较接近Chrome。&lt;/p&gt;
&lt;p&gt;CEF还提供的如下特性：自定义插件、自定义协议、自定义JavaScript对象和扩展；可控制的resource loading, navigation, context menus等等。&lt;/p&gt;
&lt;h3&gt;谁在用CEF&lt;/h3&gt;
&lt;p&gt;让我们通过一些实战中的例子，来说明大家都使用CEF做了什么：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;h5&gt;各种浏览器&lt;/h5&gt;
&lt;p&gt;早期的双核浏览器(IE + Webkit)，有些使用了CEF来作为Webkit内核浏览器控件。&lt;/p&gt;
&lt;p&gt;不过对于浏览器来说，直接在Chrome上面扩展，其实才是王道，大家现在都这么做了（各种极速浏览器）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h5&gt;Evernote Client (on Windows)&lt;/h5&gt;
&lt;p&gt;Evernote允许用户将网页粘贴到笔记中，还提供了插件用来将网页保存为笔记。&lt;/p&gt;
&lt;p&gt;那肯定是需要在Client上面可以正确的渲染页面咯，这个任务就交给了CEF。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h5&gt;GitHub Client (on Windows)&lt;/h5&gt;
&lt;p&gt;GitHub也打包了libcef.dll，从表现上面看，用来展示项目的ReadMe页面的，肯定是CEF，其他地方的UI，可能部分也是用页面来实现的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h5&gt;QQ&lt;/h5&gt;
&lt;p&gt;QQ很早之前就通过内嵌IE来实现一些功能和界面。从去年开始，QQ引入了CEF，对一些之前用IE的地方进行了替换，这样就可以使用一些基于Webkit的新特性，同时也获得了速度、稳定性、兼容性方面的优势。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h5&gt;Adobe Edge Animate &amp;amp; Adobe Edge Reflow&lt;/h5&gt;
&lt;p&gt;Adobe推出了一整套制作现代网页(或者说HTML5?)的工具，取名&lt;a href="http://html.adobe.com/edge/" target="_blank"&gt;Edge&lt;/a&gt;。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;p&gt;Adobe Edge Animate，做动画用的，可以通过编辑时间线，创建原件(Edge Animate里面叫做symbol)，来实现复杂的动画。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Edge Reflow则是Design the responsive web. 有人翻译为响应式，其实就是自适应了。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;上面两款软件，其基本面向的是Webkit内核的浏览器，那么内嵌一个Webkit内核，来提供所见即所得的预览、编辑界面就是必须的了。他们都使用了CEF。（后面会介绍CEF和纯Webkit的差别）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h5&gt;Q+&lt;/h5&gt;
&lt;p&gt;Q+在Web App的概念下，为Web页面提供了一个运行环境(简单来说就是：Client的一个框和一些可用的API)，支持IE和Webkit内核。&lt;/p&gt;
&lt;p&gt;对Web开发同学来说，我们引入的Webkit内核（实际上是CEF），无需考虑IE的版本兼容问题，既提高了开发效率，又可以利用一些新的HTML5特性。当时Q+的应用市场、消息中心、壁纸、音乐Widget等应用都是基于Webkit内核开发的。&lt;/p&gt;
&lt;p&gt;Q+项目可以说对CEF进行了比较多的尝试，比如：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;p&gt;开发的音乐Widget，就使用了HTML5的audio标签；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一些应用使用了HTML5的离线功能（就是配个manifest文件那个），当然其中也遇到些曲折，收获了不少经验。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;打包的Webkit调试工具（Dev Tools）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;自定义协议：比如对qplus://协议的访问，可以重定向到某个特殊文件夹之类的功能。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Off Screen Rendering（OSR，离屏渲染）：通过离屏渲染 + Windows的Layered Window，就制作了不规则的网页窗口（网页不透明区域是什么形状，窗口就是什么形状）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;为什么要给客户端内嵌CEF？&lt;/h3&gt;
&lt;p&gt;举了那么多例子之后，这个问题说起来就容易多了：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;h5&gt;用来展示Web页面，使用各种Web Service；&lt;/h5&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h5&gt;用Web页面来做UI；&lt;/h5&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h5&gt;使用HTML5的特性，比如audio、canvas等，包括CSS3特性等。&lt;/h5&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h5&gt;Off Screen Rendering（OSR，离屏渲染）：&lt;/h5&gt;
&lt;p&gt;所谓的OSR，就是不创建真窗口，将整个页面渲染到一张位图上面。当然不只是渲染，还有一系列的API来处理鼠标、键盘事件，处理输入法事件等。&lt;/p&gt;
&lt;p&gt;这个特性在不能使用真窗口的时候特别有用，比如Layered Window上面，或者是游戏中渲染到Texture上。&lt;/p&gt;
&lt;p&gt;利用OSR特性，可以做出一些有趣的效果，比如：&lt;/p&gt;
&lt;p&gt;AlloyTeam做出了&lt;a href="/posts/cef/webtop.alloyteam.com" target="_blank"&gt;Webtop&lt;/a&gt;，里面用OSR做了纯网页实现的浏览器、播放器等。&lt;/p&gt;
&lt;p&gt;有一个Awesomium项目，也是支持OSR，已经有游戏项目用Awesomium来在游戏中渲染网页了。
（看Awesomium的输出文件，应该和CEF的实现方式差不多，都是对Chromium的封装，Awesomium能做的CEF应该也可以做）&lt;/p&gt;
&lt;p&gt;我业余时间做了一个&lt;a href="https://github.com/zhaojunmeng/BIG" target="_blank"&gt;demo&lt;/a&gt;，用CEF将网页渲染到了OpenGL的Texture上面，也算是将CEF应用在游戏中的一小步尝试，如图：&lt;/p&gt;
&lt;p&gt;&lt;img alt="in-game browser demo" src="/assets/image/cef/cef-in-game-demo.jpg" title="in-game browser demo"&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;Why CEF?（CEF vs 其他可选方案）&lt;/h3&gt;
&lt;h4&gt;IE&lt;/h4&gt;
&lt;p&gt;IE作为内嵌的浏览器控件已经有很久的历史了，准确的说是现在我们有了很多可以替代IE的方案。&lt;/p&gt;
&lt;p&gt;CEF vs IE：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;h5&gt;兼容性：&lt;/h5&gt;
&lt;p&gt;IE：内核随着操作系统不同，版本从6到10，Web开发对这些版本的兼容工作量不可小视。&lt;/p&gt;
&lt;p&gt;CEF：使用的是Webkit内核，从特性上看，一个CEF版本，可以对应一个Chrome的版本号，这样Web开发就有了明确的特性集合，免去了考虑兼容性的工作量。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h5&gt;HTML5标准 &amp;amp; 新特性：&lt;/h5&gt;
&lt;p&gt;IE：当然旧版本的IE也不支持最新的HTML特性和标准。&lt;/p&gt;
&lt;p&gt;CEF：毫无疑问，在对新特性的支持上Webkit和Chrome都是走在前沿的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h5&gt;开源 &amp;amp; 跨平台：&lt;/h5&gt;
&lt;p&gt;IE：不开源，限Windows平台&lt;/p&gt;
&lt;p&gt;CEF：开源，使用的Webkit, Chromium都是开源的，开源就意味着更多可定制的可能；且跨Windows, Mac, Linux3个平台。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h5&gt;离屏渲染（OSR）：&lt;/h5&gt;
&lt;p&gt;IE：可以通过一些hack的方法来实现离屏渲染，但是工作量不小，而且不是官方支持的。&lt;/p&gt;
&lt;p&gt;CEF：有专门的离屏渲染模式和对应的API。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h5&gt;普及率：&lt;/h5&gt;
&lt;p&gt;IE：所有Windows用户都有IE，这是IE的优势（不过有些用户的IE设置不正缺，会导致无法使用，比如jscript.dll未注册，导致无法使用JavaScript）&lt;/p&gt;
&lt;p&gt;CEF：要自己更安装包打包&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h4&gt;Webkit&lt;/h4&gt;
&lt;p&gt;为什么要特意将CEF和Webkit做对比呢？&lt;/p&gt;
&lt;p&gt;最近看了一篇很好的文章，讲了Webkit到底是什么，不是什么，以及为什么要有那么多的Webkit port：
&lt;a href="http://www.infoq.com/cn/articles/webkit-for-developers" target="_blank"&gt;《开发者需要了解的WebKit》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这里大概总结一下：&lt;/p&gt;
&lt;p&gt;Webkit是网页的解析和排布引擎，是所有基于Webkit的浏览器共享的。默认的Webkit port是Safari，就是下载下来Webkit源码编译的版本。
除此之外还有其他的Webkit port，包括Chromium, QtWebkit等，在2D绘图、GPU加速、JavaScript引擎、audio/video解码等，都有不同的实现。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;h5&gt;CEF vs webkit（其实可以说是Chromium vs Webkit）&lt;/h5&gt;
&lt;p&gt;V8引擎，skia的2D渲染，Chromium的GPU加速的实现，等等，借助Chromium的优秀实现，使CEF也成为了一个优秀的Webkit port。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;CEF缺点：&lt;/h3&gt;
&lt;p&gt;做人要厚道，CEF也有自己的缺点和局限，也不能只提优点，这里我把CEF的缺点、劣势介绍一下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;h5&gt;体积：&lt;/h5&gt;
&lt;p&gt;最新版的CEF，所有DLL体积加起来，应该接近40M了，压缩之后估计也要10M+。
如果你的项目本身安装包体积就不大，并且也无法接收这体积，那CEF不适合你。&lt;/p&gt;
&lt;p&gt;当然对于现在按G来计算的游戏的话，这个体积应该还是可以接受的。&lt;/p&gt;
&lt;p&gt;普通的Client项目，就看项目本身需要使用CEF实现的特性，是否值得让产品的安装包增大这么多。
当然这里也有一些实现上的妥协，比如做安装后下载（个人认为这个意义不大，毕竟安装包用户还可以选择用下载软件来加速）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h5&gt;缓存：&lt;/h5&gt;
&lt;p&gt;Chrome的缓存设计成只能有一个进程读写，CEF自然也是如此。&lt;/p&gt;
&lt;p&gt;对于需要多开的Client，目前只能每个进程实例指定一个不同的缓存文件夹。但是这无疑增加了硬盘占用，也使某些本来被缓存的文件被下载了多次（比如A进程缓存了jQuery.js，B进程由于缓存不同目录，还得去请求、缓存一次jQueyr.js）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h5&gt;OSR：&lt;/h5&gt;
&lt;p&gt;OSR目前不像真窗口模式那样，可以使用GPU加速，OSR目前还只能使用软件渲染，也就是说一些CSS 3D的效果无法支持。&lt;/p&gt;
&lt;p&gt;不过OSR的特性还在不停完善中，个人认为还是值得期待。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;后续要分享的内容&lt;/h3&gt;
&lt;p&gt;写了这么多，算是一个CEF的简介吧，后续要写点儿干货，即如何使用CEF，包括：&lt;/p&gt;
&lt;p&gt;CEF代码获取，编译，嵌入，处理页面和Client的API调用，OSR离屏渲染，缓存，自定义协议，CEF1 &amp;amp; CEF3等。&lt;/p&gt;
&lt;p&gt;嗯，今天就到这里吧。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</description><guid>http://yogurtcat.com/posts/cef/hello-cef.html</guid><pubDate>Sun, 31 Mar 2013 20:20:00 GMT</pubDate></item><item><title>在GitHub上面自建博客之：Nikola</title><link>http://yogurtcat.com/posts/nikola/hello-nikola.html</link><description>&lt;html&gt;&lt;body&gt;&lt;p&gt;最近不少程序员的博客搬家到了GitHub，原因差不多有两个：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;GitHub上面写程序相关的内容，再自然不过了&lt;/li&gt;
&lt;li&gt;不限流量，且还有300M的空间（其实就是GitHub上面免费用户的版本库大小限制）&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;GitHub Pages服务：&lt;/h3&gt;
&lt;p&gt;已经有不少文章讲如何在GitHub上面建博客，其实这些都是使用了GitHub的Pages服务。&lt;/p&gt;
&lt;p&gt;简单来说，Pages服务，允许用户通过创建特殊的版本库（针对用户），或创建版本库的特殊分支（针对项目），在GitHub上面建立静态页面。将静态页面上传到版本库后（就是上传HTML, JS, CSS等），就可以通过username.github.com（用户）或projectname.github.com（项目）来访问用户或者项目的页面了。&lt;/p&gt;
&lt;p&gt;有了GitHub Pages服务，只要再配合静态页面生成工具，就能制作博客、网站了。&lt;/p&gt;
&lt;p&gt;GitHub官方提供了工具Jekyll，允许用户用轻量级标记语言（比如Markdown）来写文章，然后生成博客页面。同类的工具还有Octopress。&lt;/p&gt;
&lt;p&gt;但本文介绍的不是上面两个工具，而是一个名叫Nikola的静态页面、博客生成工具。&lt;/p&gt;
&lt;h3&gt;Nikola是啥？&lt;/h3&gt;
&lt;p&gt;Jekyll和Octopress都是Ruby写的，在决定选择哪个博客生成工具的时候，正好在学Python，于是就打算找一个Python写的博客生成工具来用~&lt;/p&gt;
&lt;p&gt;Github上面搜索了一下，排在前面的Python博客生成系统，有Pelican，Nikola。&lt;/p&gt;
&lt;p&gt;Nikola在介绍的时候说到了自己Fast，为了这个关键词，我决定一试！（虽然我没有跟其他工具比较过_(:з」∠)_）&lt;/p&gt;
&lt;p&gt;PS:为啥没选择Pelican，Pelican在生成页面的时候，使用了make脚本，在Windows上面用make的话，需要MinGW，我这个典型Windows用户就放弃了（虽然我电脑上面有MinGW_(:з」∠)_）。&lt;/p&gt;
&lt;h3&gt;Nikola安装篇&lt;/h3&gt;
&lt;p&gt;官方文档中的安装，简单的归纳，实际上就是&lt;a href="http://nikola.ralsina.com.ar/handbook.html#installing-nikola" target="_blank"&gt;一句话&lt;/a&gt;：&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre&gt;&lt;span class="n"&gt;pip&lt;/span&gt; &lt;span class="n"&gt;install&lt;/span&gt; &lt;span class="n"&gt;https&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="c1"&gt;//github.com/ralsina/nikola/archive/master.zip&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;当然了，这里也可以使用其他的Python包安装工具，比如我用的是 easy_install&lt;/p&gt;
&lt;h4&gt;安装篇之Windows篇&lt;/h4&gt;
&lt;p&gt;不过，在Windows上安装Nikola，有些额外的工作要做：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;h5&gt;lxml&lt;/h5&gt;
&lt;p&gt;Nikola的requirements：lxml&lt;/p&gt;
&lt;p&gt;这个在安装的时候，是需要用代码编译的，但是在Windows上面，却编译不通过，解决办法是去下载一个Windows版本的安装包装上，就ok了，我选的是lxml-2.3.win32-py2.7.exe：&lt;/p&gt;
&lt;p&gt;&lt;a href="http://pypi.python.org/simple/lxml/" target="_blank"&gt;http://pypi.python.org/simple/lxml/&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h5&gt;环境变量&lt;/h5&gt;
&lt;p&gt;当试图运行&lt;code&gt;nikola init&lt;/code&gt;命令时，如果遇到下面的错误：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;'nikola' 不是内部或外部命令，也不是可运行的程序或批处理文件。&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;是&lt;code&gt;C:\Python27\Scripts\&lt;/code&gt;未添加到环境变量PATH中，&lt;code&gt;C:\Python27&lt;/code&gt;是我的Python安装目录。（实际上在使用Python的包安装工具的时候，应该已经将该路劲添加到环境变量中了~）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;使用篇&lt;/h3&gt;
&lt;p&gt;安装完成，赶快来一发吧骚年：&lt;/p&gt;
&lt;p&gt;下面简单翻译自&lt;a href="http://nikola.ralsina.com.ar/handbook.html#all-you-need-to-know" target="_blank"&gt;Nikola文档&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;h5&gt;新建一个空网站:&lt;/h5&gt;
&lt;div class="code"&gt;&lt;pre&gt;&lt;span class="n"&gt;nikola&lt;/span&gt; &lt;span class="n"&gt;init&lt;/span&gt; &lt;span class="n"&gt;mysite&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;要新建个包含demo文件的Nikola demo网站的话，使用:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre&gt;&lt;span class="n"&gt;nikola&lt;/span&gt; &lt;span class="n"&gt;init&lt;/span&gt; &lt;span class="n"&gt;mysite&lt;/span&gt; &lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="n"&gt;demo&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;/ul&gt;&lt;h5&gt;剩下的命令要在Nikola新建的网站文件夹中执行，比如刚才的mysite文件夹（cd mysite）&lt;/h5&gt;
&lt;ul&gt;&lt;li&gt;
&lt;h5&gt;新建一篇文章:&lt;/h5&gt;
&lt;div class="code"&gt;&lt;pre&gt;&lt;span class="n"&gt;nikola&lt;/span&gt; &lt;span class="n"&gt;new_post&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;执行&lt;code&gt;new_post&lt;/code&gt;命令之后，会提示你填写文章名等信息来完成创建。
创建完成后，找到刚才新建的文件，就可以对文章进行编辑啦。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h5&gt;编辑完成后，构建你的网站吧:&lt;/h5&gt;
&lt;div class="code"&gt;&lt;pre&gt;&lt;span class="n"&gt;nikola&lt;/span&gt; &lt;span class="n"&gt;build&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;h5&gt;启动个local server:&lt;/h5&gt;
&lt;div class="code"&gt;&lt;pre&gt;&lt;span class="n"&gt;nikola&lt;/span&gt; &lt;span class="n"&gt;serve&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;h5&gt;使用下面的地址来预览:&lt;/h5&gt;
&lt;div class="code"&gt;&lt;pre&gt;&lt;span class="nl"&gt;http:&lt;/span&gt;&lt;span class="c1"&gt;//127.0.0.1:8000&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;哪，一个最简单的静态博客新鲜出炉了！&lt;/p&gt;
&lt;h3&gt;部署到Github Pages上！&lt;/h3&gt;
&lt;p&gt;最后，只要把mysite下面的output文件夹，push到GitHub上面即可（&lt;a href="http://pages.github.com/" target="_blank"&gt;详见GitHub Pages文档&lt;/a&gt;）。&lt;/p&gt;
&lt;p&gt;创建用户页面需要的版本库时，遇到了个问题：&lt;/p&gt;
&lt;p&gt;一开始以为，创建一个和自己username同名的版本库，然后push文件，再访问username.github.com即可。&lt;/p&gt;
&lt;p&gt;但是即使文件正确上传，却总是看到404页面。&lt;/p&gt;
&lt;p&gt;后来看到了别人的版本库，发现原来版本库的名字要叫username.github.com！而不是单纯的username！&lt;/p&gt;
&lt;p&gt;比如我的id是zhaojunmeng，那新建一个zhaojunmeng的版本库是不行的，必须是&lt;a href="/posts/nikola/zhaojunmeng.github.com" target="_blank"&gt;zhaojunmeng.github.com&lt;/a&gt;这个版本库。&lt;/p&gt;
&lt;p&gt;上传成功之后，只要等等去刷新下页面就好啦。官方说是10分钟，不过现在看来，貌似不用10分钟就可以看到页面啦！&lt;/p&gt;
&lt;h3&gt;Why Static&lt;/h3&gt;
&lt;p&gt;折腾了这么半天，为啥要建一个静态的博客呢？&lt;/p&gt;
&lt;p&gt;Nikola的文档&lt;a href="http://nikola.ralsina.com.ar/handbook.html#why-static" target="_blank"&gt;Why Static&lt;/a&gt;说了很多，我这里就大概说一下。&lt;/p&gt;
&lt;p&gt;所谓动态网站，指的是网站的内容存放在后台数据库中，当用户访问网页的时候，后台程序根据数据动态地生成HTML页面返回给用户。&lt;/p&gt;
&lt;p&gt;静态网站呢，整个站点的每一个页面，每一个文件，在用户访问之前就已经存在在了服务器上面。&lt;/p&gt;
&lt;p&gt;相比动态网站，静态网站的优点有：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;h5&gt;低开销，高性能&lt;/h5&gt;
&lt;p&gt;动态网站处理每一次用户访问，都伴随着数据库查询、数据处理来生成HTML，这就消耗了服务器的CPU和内存。&lt;/p&gt;
&lt;p&gt;而静态网站只依靠HTTP server，开销自然低很多。（对于云计算平台来说，省下了开销就省了钱）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h5&gt;依赖工具少，省心&lt;/h5&gt;
&lt;p&gt;使用动态网站，比如WordPress建的博客，你可能就需要经常WordPress版本；或者host提供者升级了支持的php或者Python版本，你也需要做些升级工作。&lt;/p&gt;
&lt;p&gt;而静态网站，生成的都是最终的HTML页面，假设静态网站生成工具升级，比如Nikola，你不升级，也不影响对现在任何功能的使用。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h5&gt;方便搬家&lt;/h5&gt;
&lt;p&gt;静态网站的搬家，无需经历数据的导出/导入的过程，只要将页面上传到一个新的host上面即可工作。（比如可以从GitHub Pages服务，转移到BitBucket Pages服务上面）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h5&gt;更安全&lt;/h5&gt;
&lt;p&gt;都是静态的HTML，也不写什么数据库，没有依赖的后台软件，都让静态网站更安全了。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;看了上面，可能有人会想：静态网站会不会功能少啊？&lt;/p&gt;
&lt;p&gt;其实……不会。&lt;/p&gt;
&lt;p&gt;通过在HTML代码中，引入一些第三方的js文件，静态网站同样可以内嵌评论、分享等组件，只是数据不是存在你的网站，而是存在第三方的后台中。&lt;/p&gt;
&lt;h3&gt;然后呢？——未完待续&lt;/h3&gt;
&lt;p&gt;上面只是介绍了静态网站、GitHub Pages、如何开始使用Nikola等，并没有覆盖Nikola的特性。&lt;/p&gt;
&lt;p&gt;比如，Nikola使用了Bootstrap，可以更换主题等，全部的特性请查看：&lt;a href="http://nikola.ralsina.com.ar/handbook.html#features" target="_blank"&gt;http://nikola.ralsina.com.ar/handbook.html#features&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;后面会逐步介绍，在Nikola中定制自己博客的技巧，比如分享啊，评论啊，二维码啊，标签云啊等等等等，敬请期待_(:з」∠)_&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</description><guid>http://yogurtcat.com/posts/nikola/hello-nikola.html</guid><pubDate>Mon, 18 Mar 2013 20:20:00 GMT</pubDate></item><item><title>Hello World, Hello 2013</title><link>http://yogurtcat.com/posts/hello-world.html</link><description>&lt;html&gt;&lt;body&gt;&lt;p&gt;时光飞逝，2013年就这么已经过去两个月了，我也终于开始要写点儿啥。&lt;/p&gt;
&lt;p&gt;其实之前一直有些零散的东西想要记下来，但就是不想往博客上面更新，总觉得这里不爽那里不对的。&lt;/p&gt;
&lt;p&gt;作为一个程序员，自己折腾个网站也算是程序员的自我修养之一，干脆都写在自己的网站上面好了，自己的东西，自己不满意就去改，多自在。&lt;/p&gt;
&lt;p&gt;当然按照程序员的传统，一门新的语言，都要写一个Hello World出来，那我自己的网站，第一篇也就是Hello World了。&lt;/p&gt;
&lt;p&gt;后面打算定期更新些内容，从九城辞职，在腾讯这一年多的收获、心得都放上来，还有自己也可以写些HTML5或者NaCl相关的demo，还有其他一些好玩的东西，都是自己之前没接触过的，扔上来，反正自己的页面，想怎么折腾就怎么折腾。&lt;/p&gt;
&lt;p&gt;最后送上LP画的蛇年贺图一张，祝大家坚持住自己的梦想，并且梦想成真！&lt;/p&gt;
&lt;p&gt;&lt;img alt="蛇年贺图" src="/galleries/jiafeimao2013/shenianhetu.jpg" title="蛇年贺图"&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</description><guid>http://yogurtcat.com/posts/hello-world.html</guid><pubDate>Tue, 26 Feb 2013 23:01:23 GMT</pubDate></item></channel></rss>